## 信号

> 信号是在软件层次上对中断机制的模拟，是一种异步通信的方式。

 **同步通信&异步通信**

> 计算机内部的component交流需要时钟来管理。
>
> 那么，时钟差的很小，就是同步。
>
> 跟时钟关系不大，就是异步。
>
> 同步较复杂，需要成本，技术，时钟要求高。
>
> 异步实现简单，效率低。
>
> 建议：内部component的时间差的不大的可以用同步。

---

> 信号可以直接进行用户空间进程和内核进程之间的交互，
>
> 内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。

> 信号可以直接发送而不用关心进程状态。
>
> 如果进程被阻塞，那么先由内核保管。那么等他出来，内核再发。

### linux支持的信号列表

```
kill -l
```

```
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```

```
在Linux中，信号值在32 之前的有不同的名称，而信号值在 32 以后的都是用“ SIGRTMIN”或“ SIGRTMAX”开头的，这就是两类典型的信号。
```

```
前者是从 UNIX 系统中继承下来的信号，为不可靠信号（也称为非实时信号）
```

```
后者是为了解决前面“不可靠信号”的问题而进行了更改和扩充的信号，称为“可靠信号”（也称为实时信号）
```

| 表6 常见信号的含义及其默认操作 |                                                              |          |
| ------------------------------ | ------------------------------------------------------------ | -------- |
| 信号名                         | 含义                                                         | 默认操作 |
| SIGHUP                         | 该信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束时，通知同一会话内的各个作业与控制终端不再关联 | 终止     |
| SIGINT                         | 该信号在用户键入INTR字符（通常是Ctrl-C）时发出，终端驱动程序发送此信号并送到前台进程中的每一个进程 | 终止     |
| SIGQUIT                        | 该信号和SIGINT 类似，但由QUIT字符（通常是Ctrl-\）来控制，类似于一个程序错误信号 | 终止     |
| SIGILL                         | 该信号在一个进程企图执行一条非法指令时（可执行文件本身出现错误，或者试图执行数据段、堆栈溢出时）发出 | 终止     |
| SIGFPE                         | 该信号在发生致命的算术运算错误时发出。这里不仅包括浮点运算错误，还包括溢出及除数为0 等其他所有的算术错误 | 终止     |
| SIGKILL                        | 该信号用来立即结束程序的运行，并且不能被阻塞、处理或忽略     | 终止     |
| SIGALRM                        | 该信号当一个定时器到时的时候发出                             | 终止     |
| SIGSTOP                        | 该信号用于暂停一个进程，且不能被阻塞、处理或忽略             | 暂停进程 |
| SIGTSTP                        | 该信号用于交互停止进程，用户键入SUSP 字符时（通常是Ctrl+Z）发出这个信号，可以被阻塞、处理或忽略 | 停止进程 |
| SIGCHLD                        | 子进程改变状态时，父进程会收到这个信号                       | 忽略     |
| SIGCONT                        | 恢复暂停的进程                                               | 恢复进程 |
| SIGABORT                       | 进程异常终止时发出                                           | 终止     |

### 信号的生命周期

```
完整的生命周期为:信号产生、信号在进程中注册、信号在进程中注销、执行信号处理函数
```

```
那么为什么之前的信号不可靠呢？
```

```
一个不可靠信号的处理过程是这样的：如果发现该信号已经在进程中注册，那么就忽略该信号。因此，若前一个信号还未注销又产生了相同的信号就会产生信号丢失。
```

```
而当可靠信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此信号就不会丢失。
```

### 进程对信号的响应

- 忽略
  - 即对信号不做任何处理，但是有两个信号不能忽略，即SIGKILL和SIGSTOP。
- 捕捉
  - 定义信号处理函数，当信号发生时，执行相应的自定义处理函数。
- 执行缺省
  - 执行默认操作。Linux 对每种信号都规定了默认操作。

